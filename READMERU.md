# Django Tree Menu

Django-приложение для иерархической навигации с эффективными запросами к базе данных и гибкими режимами отображения с демо-страницами.

### Демо-сайт

Взаимодействуйте с древовидным меню в реальном окружении на развёрнутом демо-сайте.

Переключайтесь между плоским и выпадающим режимами навигации

Наблюдайте автоматическое раскрытие активной ветки

Переходите по примерам страниц, работающих на этом бэкенде:
http://13.53.73.97:8009

Ссылка на админ-панель этого сайта:
- http://13.53.73.97:8009/admin
- email: admin@admin.com
- password: 12

## Видео-обзор

Для быстрого ознакомления с функциями и поведением проекта посмотрите видео-обзор:

▶️ Смотрите обзор Django Tree Menu на YouTube: https://youtu.be/K4NHN2cgDC0

## Обзор

Этот проект реализует переиспользуемую систему древовидного меню, которая решает распространённые требования к навигации в Django-приложениях:

- Один запрос к базе данных на отрисовку меню
- Автоматическое определение и раскрытие активной ветки
- Поддержка как плоского, так и выпадающего макета меню
- Разрешение именованных URL с резервным вариантом

## Ключевые возможности

### Основной функционал

- **Отрисовка через template tag** — `{% draw_menu 'menu_name' %}` генерирует полные древовидные меню
- **URL-зависимая активация** — Автоматическое определение активных страниц через сопоставление путей запроса
- **Двойная поддержка URL** — Именованные URL (Django `reverse()`) с явным резервным URL
- **Несколько экземпляров меню** — Отображение независимых меню на одной странице
- **Настраиваемые режимы отображения** — Плоские списки или выпадающие обёртки для каждого меню

### Интерфейс администратора

- **Выпадающие списки выбора URL** — Автоматически заполняемый список доступных именованных URL
- **Встроенное редактирование** — Управление пунктами меню напрямую со страниц редактирования меню

### Производительность

- **Оптимизированные запросы** — Один запрос на меню с использованием `select_related()` и `prefetch_related()`
- **Построение дерева** — Построение дерева в памяти из плоского набора запросов
- **Минимальная логика в шаблонах** — Вычисление активного состояния происходит в Python

## Техническая архитектура

```
apps/tree_menu/
├── models/
│   ├── menu.py              # Контейнер меню с настройками отображения
│   └── menu_item.py         # Иерархические пункты меню
├── templatetags/
│   └── tree_menu_tags.py    # Template tag и построитель дерева
├── templates/tree_menu/
│   ├── menu.html            # Корневой шаблон с выбором режима
│   └── menu_node.html       # Рекурсивный рендерер узлов
├── admin.py                 # классы администратора
├── utils.py                 # вспомогательные функции
└── views.py                 # Демо-представления
```

### Модель данных

**Menu**

- `name` (CharField, unique) — Идентификатор template tag
- `verbose_name` (CharField) — Отображаемое имя в админке
- `render_as_dropdown` (BooleanField) — Флаг режима отображения
- `dropdown_title` (CharField) — Текст родительского элемента для режима выпадающего меню

**MenuItem**

- `menu` (ForeignKey) — Родительское меню
- `parent` (ForeignKey, self-referential) — Поддержка иерархии
- `title` (CharField) — Отображаемый текст
- `named_url` (CharField) — Имя Django URL
- `url` (CharField) — Явный резервный URL
- `order` (PositiveIntegerField) — Порядок сортировки

### Логика отрисовки

1. Template tag извлекает все элементы для меню (один запрос)
2. Построитель дерева создаёт иерархию узлов с флагами активного состояния
3. Определение активности использует точное совпадение или совпадение самого длинного префикса
4. Шаблон рекурсивно отрисовывает узлы, раскрывая активные ветки

## Установка

### Требования

- Python 3.11+
- PostgreSQL 12+
- Docker & Docker Compose (для контейнеризованного развёртывания)

### Быстрый старт с Docker

```bash
# Клонируйте репозиторий
git clone https://github.com/bahodir0902/TreeMenuBackend.git
cd TreeMenuBackend

# Запустите сервисы
docker compose up --build

# Доступ к приложению
# Веб: http://localhost:8000
# Админка: http://localhost:8000/admin
```

Учётные данные администратора по умолчанию создаются через `entrypoint.sh`.

### Настройка локальной разработки

```bash
# Создайте виртуальное окружение
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# Установите зависимости (pip)
pip install -r requirements.txt

# Или с Poetry
poetry install
poetry shell

# Настройте окружение
cp .env.example .env
# Отредактируйте .env с вашими учётными данными базы данных

# Запустите миграции
python manage.py migrate

# Создайте суперпользователя
python manage.py createsuperuser

# Запустите сервер разработки
python manage.py runserver
```

### Конфигурация окружения

Необходимые переменные в `.env`:

```env
DB_NAME=db_name
DB_USER=db_user
DB_PASSWORD=db_password
DB_HOST=localhost
DB_PORT=db_port (или host.docker.internal) при развёртывании
SECRET_KEY=your-secret-key
DEBUG=True
```

### Pre-commit хуки

```bash
# Установите pre-commit
pip install pre-commit

# Установите git хуки
pre-commit install

# Запустите вручную
pre-commit run --all-files
```

## Использование

### Интеграция в шаблоны

```django
{% load tree_menu_tags %}

<!DOCTYPE html>
<html>
<body>
    <header>
        <!-- Плоское навигационное меню -->
        {% draw_menu 'main_menu' %}
    </header>

    <aside>
        <!-- Боковое меню -->
        {% draw_menu 'sidebar_menu' %}
    </aside>

    <nav>
        <!-- Выпадающее меню в подвале -->
        {% draw_menu 'footer_menu' %}
    </nav>
</body>
</html>
```

### Настройка в админке

#### Создание меню

1. Перейдите в Админка → Меню → Добавить меню
2. Установите системное имя (например, `main_menu`)
3. Выберите режим отображения:
    - Плоский: Элементы отображаются как соседние
    - Выпадающий: Элементы оборачиваются в родительский элемент
4. Добавьте пункты меню с иерархией

#### Конфигурация URL

Пункты меню поддерживают два типа URL с автоматическим резервным вариантом:

- **Именованный URL** (рекомендуется): Выберите из выпадающего списка доступных URL
- **Явный URL**: Ручной ввод пути (например, `/contact/`)

Именованные URL разрешаются во время отрисовки. Если разрешение не удаётся, используется явный URL.

### Режимы отображения меню

**Плоский режим** (по умолчанию)

```
[Главная] [Каталог...] [О проекте] [Контакты]
```

Используйте для: Основной навигации, ссылок в подвале, хлебных крошек

**Режим выпадающего меню**

```
[Профиль ▼]
  └─ Аккаунт
  └─ Настройки
  └─ Выйти
```

Используйте для: Меню пользователя, переключателей языка, действий администратора

## Разработка

### Структура проекта

```
.
├── apps/
│   └── tree_menu/          # Основное приложение
├── core/                   # Настройки Django
├── templates/              # Глобальные шаблоны
├── static/                 # Статические ресурсы
├──
├── Dockerfile              # Конфигурация Docker-образа
├── docker-compose.yml      # Конфигурация мульти-контейнера
└── entrypoint.sh
├── .github/
│   └── workflows/          # CI/CD пайплайны
├── pyproject.toml          # Конфигурация Poetry
├── requirements.txt        # Зависимости Pip (старый)
└── .pre-commit-config.yaml # Pre-commit хуки
```

### Качество кода

Проект использует:

- **Black** — Форматирование кода
- **isort** — Сортировка импортов
- **flake8** — Линтинг
- **mypy** — Проверка типов (опционально)

Конфигурация определена в `pyproject.toml` и `.pre-commit-config.yaml`.

### Миграции базы данных

```bash
# Создайте миграции
python manage.py makemigrations

# Примените миграции
python manage.py migrate

# Покажите план миграций
python manage.py showmigrations
```

## Развёртывание

### Продакшн-сборка Docker

```bash
# Запустите с compose
docker compose up --build -d
```

### Статические файлы

```bash
# Соберите статические файлы
python manage.py collectstatic --no-input

# Настройте веб-сервер для обслуживания /static/ и /media/
```

### Переменные окружения для продакшн

## Соображения производительности

### Оптимизация запросов

Каждый вызов `draw_menu` выполняет ровно один запрос:

```python
items = MenuItem.objects.filter(menu__name=menu_name)
    .select_related('parent', 'menu')
    .order_by('order', 'id')
```

Построение дерева происходит в Python, а не в базе данных.

### Масштабирование

- Пункты меню предзагружаются одним запросом
- Нет проблем N+1 запросов
- Построение дерева имеет сложность O(n), где n = количество элементов
- Отрисовка шаблона имеет сложность O(n) с ранним завершением для свёрнутых веток

## Участие в разработке

1. Форкните репозиторий
2. Создайте ветку функции (`git checkout -b feature/improvement`)
3. Закоммитьте изменения (`git commit -m 'Add feature'`)
4. Запушьте в ветку (`git push origin feature/improvement`)
5. Откройте Pull Request

## Лицензия

Этот проект предоставляется как есть для демонстрационных и образовательных целей.
То есть, вы можете использовать этот проект как пожелаете.

## Требования

Смотрите `requirements.txt` или `pyproject.toml` для полного списка зависимостей.
